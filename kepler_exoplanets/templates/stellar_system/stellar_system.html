{% extends "main/base.html" %}
{% block content %}
{% include 'sidebar/sidebar_stellarsystem.html' %}
{% include "partials/_starfragment.html" %}
{% include "partials/_starvertex.html" %}
{% include 'partials/_gasfragment.html' %}
{% include 'partials/_gasvertex.html' %}

  <div id="space_container"></div>
    <script type="text/javascript">
      $(function() {
        var controls, camera, scene, renderer, container, intersects, winResize;

        var t = 0;
        var s = 1;
        var cam = {{ planets.last.semimajor_axis }} * 700;
        // Orbits circles
        var circleSegments = 64;
        var circleMaterial = new THREE.LineBasicMaterial( { color: 0xF0C400 } );
        var circles = [];

        var planets = [],
            initialY = [],
            speed = [],
            paths = [];
        // Set up canvas dimensions
        var windowwidth = window.innerWidth;
        var width = windowwidth * 0.66667;
        var height = window.innerHeight;

        // Set up tools for hover and click events
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;

        start();

        function start(){
        //Scene creation
        scene = new THREE.Scene();
        container = document.getElementById( 'space_container' );

        //resizes canvas when window is
        winResize = new THREEx.WindowResize(renderer, camera);
        // PerspectiveCamera creation and Set up
        camera = new THREE.PerspectiveCamera(75, width/height, 1, 1000);
        camera.position.set(0, - cam, cam);
        scene.add(camera);

        // Set up camera controls (using Orbit)
        controls = new THREE.OrbitControls( camera );
        controls.minDistance = 100;
        controls.maxDistance = 500;

        // Create the WebGL renderer and append it to the DOM bia the body element
        renderer = new THREE.WebGLRenderer({alpha: true});
        renderer.setClearColor(0xffffff, 0);
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        // Create and add the star to the stellar system
        addStar({{ star.stellar_radius }});

        // Create and add planets to the stellar system
        {% for planet in planets %}
            var url = "{% url 'planet' planet.pk %}";
            // Planet sizes have a minimun of 1 and a maximum of 5
            {% if planet.planet_radius < 1 %}
              planetRadius = 1
            {% elif planet.planet_radius > 5 %}
              planetRadius = 5
            {% else %}
              planetRadius = {{ planet.planet_radius }}
            {% endif %}

            selectPlanet(planetRadius, {{ planet.surface_temp }}, {{ planet.semimajor_axis }}, url);
            initialY.push({{ planet.semimajor_axis }} * 2.5);

            {% if planet.orbital_period == null %}
              orbperiod = 15
            {% else %}
              orbperiod = {{ planet.orbital_period }}
            {% endif %}
            speed.push(orbperiod);
        {% endfor %}
          launch = Date.now();
          animate();

        }

        function animate(){
          requestAnimationFrame(animate);
          starmaterial.uniforms[ 'time' ].value = .00025 * ( Date.now() - launch );
          t += (0.0005 * s);
          star.rotation.z += 0.005;
          planets.forEach(rotatePlanet);

          grabPlanets();
          if ( intersects.length > 0 ) {
            $('canvas').css('cursor', 'pointer');
          }
          else {
            $('canvas').css('cursor', 'auto');
          }

          //resizes canvas when window is
          winResize = new THREEx.WindowResize(renderer, camera);
          renderer.render(scene, camera);
          controls.update();
        }

        // add the star
        function addStar(size) {
          var geometry = new THREE.IcosahedronGeometry( size * 10, 5 );
          starmaterial = new THREE.ShaderMaterial({
            uniforms: {
              tExplosion: {
                type: "t",
                value: Textures.sunexplocolor
              },
              time: { // float initialized to 0
                type: "f",
                value: 0.0
              }
            },
          vertexShader: document.getElementById( 'star-vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'star-fragmentShader' ).textContent
          });
          star = new THREE.Mesh( geometry, starmaterial );
          scene.add( star );
          pointLight = new THREE.PointLight( 0xffffff, 2 );
          scene.add( pointLight );
          pointLight.add( star );
        }

        // select which type of planet to add
        function selectPlanet(size, temp, distance, url) {
          distance = distance * 2;
          if  (temp > 273 && temp < 373 && size < 2) {
            addHabitable(size, distance, url);
           }
          else if (size > 4) {
            addRed(size, distance, url);
          }
          else if (size > 2) {
            addBlue(size, distance, url);
          }
          else {
            addRocky(size, distance, url);
          }
        };
        // add Red Gas Planet
        function addRed(size, distance, path) {
          redMaterial = new THREE.ShaderMaterial({
            uniforms: {
              tExplosion: {
                type: "t",
                value: Textures.redexplocolor
              },
              time: {
                type: "f",
                value: 0.0
              }
            },
          vertexShader: document.getElementById( 'gas-vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'gas-fragmentShader' ).textContent
          });
          geometry = new THREE.IcosahedronGeometry( size, 5 );
          planet = new THREE.Mesh( geometry, redMaterial );
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 250);
        }

        // add Blue Gas Planet
        function addBlue(size, distance, path) {
          blueMaterial = new THREE.ShaderMaterial({
            uniforms: {
              tExplosion: {
                type: "t",
                value: Textures.blueexplocolor
              },
              time: {
                type: "f",
                value: 0.0
              }
            },
          vertexShader: document.getElementById( 'gas-vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'gas-fragmentShader' ).textContent
          });
          geometry = new THREE.IcosahedronGeometry( size, 5 );
          planet = new THREE.Mesh( geometry, blueMaterial );
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 250)
        }

        // add rocky planet
        function addRocky(size, distance, path) {
          geometry = new THREE.SphereGeometry(size, 15, 15);
          rockyMaterial = new THREE.MeshPhongMaterial({ map: Textures.rockytexture, bumpMap: Textures.rockybump, bumpScale: 1  });
          planet = new THREE.Mesh(geometry, rockyMaterial);
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 250)
        }

        // add habitable planet
        function addHabitable(size, distance, path) {
          geometry = new THREE.SphereGeometry(size, 15, 15);
          habitableMaterial = new THREE.MeshPhongMaterial({ map: Textures.habitabletexture, bumpMap: Textures.habitablebump, bumpScale: 1  });
          planet = new THREE.Mesh(geometry, habitableMaterial);
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 250)
        }

        // add a orbit circle to the planet
        function addCircle(distance) {
          geometry = new THREE.CircleGeometry( distance, circleSegments );
          geometry.vertices.shift();
          circle = new THREE.Line(geometry,  circleMaterial);
          circles.push(circle);
          scene.add(circle);
        }

        // planets rotation
        function rotatePlanet(planet, index) {
          planet.rotation.z += 0.05;
          planet.position.y = initialY[index] * 200 * Math.cos(t * speed[index]) + 0 * Math.sin(t * speed[index]);
          planet.position.x = 0 * Math.cos(t * speed[index]) - initialY[index] * 200 * Math.sin(t * speed[index]);
        }

        // Make the planets clickable (for now, it alerts the coordinates)
        document.addEventListener('click', onDocumentMouseClick, false);
        function onDocumentMouseClick() {
          grabPlanets();
          if (intersects.length > 0) {
            clickedPlanet = intersects[0].object;
            if (clickedPlanet.id == 6) {
              window.location = "{% url 'star' star.pk %}";
            }
            else if (clickedPlanet.id % 2 == 1)
            {
              window.location = paths[clickedPlanet.id];
            }
            else {
              window.location = paths[clickedPlanet.id - 1];
            }
          }
        }

        // Deactivate orbit controls when interacting with the panel
        // Show/hide orbit circles
        $('.sidebar').on('mouseenter', function() {
          controls.enabled = false;
          skybox_controls.enabled = false;
        });

        $('.sidebar').on('mouseleave', function() {
          controls.enabled = true;
          skybox_controls.enabled = true;
        });

        $('#flip-orbit').on('change', function(){
          if ($('#flip-orbit').val() == 'off') {
            circles.map(function(circle){circle.visible = false});
          } else {
            circles.map(function(circle){circle.visible = true});
          };
        });

        $('#flip-view').on('change', function(){
          if ($('#flip-view').val() == '3d') {
            camera.position.set(0, - cam, cam);
          } 

          else if ($('#flip-view').val() == 'transit') {
            camera.position.set(0, cam, 0);
          } 

          else {
            camera.position.set(0, 0, cam);
          };
        });

        $( "#slider-1" ).slider({
          animate: true,
          max: 1000,
          min: 0,
          value: 100,
          slide: function( mousemove, speed) {
            s = speed.value / 100;
            console.log(s);
        }
      });

        // Register the targeted planet with click events
        function grabPlanets() {
          raycaster.setFromCamera(mouse, camera);
          intersects = raycaster.intersectObjects(scene.children, true);
        };
      });

      function onDocumentMouseMove( event ) {
        event.preventDefault();
        var offset = {
          x: document.getElementsByTagName("canvas")[0].offsetLeft,
          y: document.getElementsByTagName("canvas")[0].offsetTop,
        }
        mouse.x = ((event.clientX - offset.x) / renderer.domElement.width) * 2 - 1;
        mouse.y = 1 - ((event.clientY - offset.y) / renderer.domElement.height) * 2;
      }

    </script>
  {% endblock %}
