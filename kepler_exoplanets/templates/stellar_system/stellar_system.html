{% extends "main/base.html" %}

{% block content %}
{% include 'sidebar/sidebar_stellarsystem.html' %}
{% include "partials/_starfragment.html" %} 
{% include "partials/_starvertex.html" %}
{% include 'partials/_gasfragment.html' %}
{% include 'partials/_gasvertex.html' %}

  <div id="space_container"></div> 
    <script type="text/javascript">
      $(function() {
        var controls, camera, scene, renderer, container, intersects, winResize;

        var t = 0;
        // Orbits circles
        var circleSegments = 64;
        var circleMaterial = new THREE.LineBasicMaterial( { color: 0xF0C400 } );
        var circles = [];

        var planets = [],
            initialY = [],
            speed = [],
            paths = [];

    
        // Set up canvas dimensions
        var windowwidth = window.innerWidth;
        var width = windowwidth * 0.66667;
        var height = window.innerHeight;

        // Set up tools for hover and click events
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2(), INTERSECTED;

        start();

        function start(){
        //Scene creation
        scene = new THREE.Scene();
        container = document.getElementById( 'space_container' );

        //resizes canvas when window is
        winResize = new THREEx.WindowResize(renderer, camera);
        // PerspectiveCamera creation and Set up. Parameters
        // 1. FOV – We’re using 45 degrees for our field of view.
        // 2. Aspect – We’re simply dividing the browser width and height to get an aspect ratio.
        // 3. Near – This is the distance at which the camera will start rendering scene objects.
        // 4. Far – Anything beyond this distance will not be rendered. Perhaps more commonly known as the draw distance.
        camera = new THREE.PerspectiveCamera(75, width/height, 1, 1000);
        camera.position.set(0, 0, 100);
        scene.add(camera);

        // Set up camera controls (using Orbit)
        controls = new THREE.OrbitControls( camera );
        controls.rotateSpeed = 1;
        controls.minDistance = 0;
        controls.maxDistance = 500;

        // Create the WebGL renderer and append it to the DOM bia the body element
        renderer = new THREE.WebGLRenderer({alpha: true});
        renderer.setClearColor(0xffffff, 0);
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        // Create and add the star to the stellar system
        addStar({{ star.stellar_radius }});
      
        // Create and add planets to the stellar system
        {% for planet in planets %}
            var url = "{% url 'planet' planet.pk %}";
            selectPlanet({{ planet.planet_radius }}, {{ planet.surface_temp }}, {{ planet.semimajor_axis }}, url);
            initialY.push({{ planet.semimajor_axis }});
            speed.push({{ planet.orbital_period }})
        {% endfor %} 

          launch = Date.now();
          animate();

        };

        function animate() {
          requestAnimationFrame(animate);
          starmaterial.uniforms[ 'time' ].value = .00025 * ( Date.now() - launch );
          t += 0.0005;
          star.rotation.z += 0.005;
          planets.forEach(rotatePlanet);
          renderer.render(scene, camera);
          controls.update();
        };

        // add the star
        function addStar(size) {
          var geometry = new THREE.IcosahedronGeometry( size * 10, 5 );
          starmaterial = new THREE.ShaderMaterial({
            uniforms: {
              tExplosion: {
                type: "t",
                value: Textures.sunexplocolor
              },
              time: { // float initialized to 0
                type: "f",
                value: 0.0
              }
            },
          vertexShader: document.getElementById( 'star-vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'star-fragmentShader' ).textContent
          });
          star = new THREE.Mesh( geometry, starmaterial );
          scene.add( star );
          pointLight = new THREE.PointLight( 0xffffff );
          scene.add( pointLight );
          pointLight.add( star );
        };

        // select which type of planet to add
        function selectPlanet(size, temp, distance, url) {
          distance = distance * 2;
          if  (temp > 273 && temp < 373) {
            addHabitable(size, distance, url);
           }
          else if (size > 4) {
            addRed(size, distance, url);
          }
          else if (size > 2) {
            addBlue(size, distance, url);
          }
          else {
              addRocky(size, distance, url);
            }
        };

        // add Red Gas Planet
        function addRed(size, distance, path) {
          redMaterial = new THREE.ShaderMaterial({
            uniforms: {
              tExplosion: {
                type: "t",
                value: Textures.redexplocolor
              },
              time: {
                type: "f",
                value: 0.0
              }
            },
          vertexShader: document.getElementById( 'gas-vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'gas-fragmentShader' ).textContent
          });
          geometry = new THREE.IcosahedronGeometry( size, 5 );
          planet = new THREE.Mesh( geometry, redMaterial );
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 100);
        }

        // add Blue Gas Planet
        function addBlue(size, distance, path) {
          blueMaterial = new THREE.ShaderMaterial({
            uniforms: {
              tExplosion: {
                type: "t",
                value: Textures.blueexplocolor
              },
              time: {
                type: "f",
                value: 0.0
              }
            },
          vertexShader: document.getElementById( 'gas-vertexShader' ).textContent,
          fragmentShader: document.getElementById( 'gas-fragmentShader' ).textContent
          });
          geometry = new THREE.IcosahedronGeometry( size, 5 );
          planet = new THREE.Mesh( geometry, blueMaterial );
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 100)
        }

        // add rocky planet
        function addRocky(size, distance, path) {
          geometry = new THREE.SphereGeometry(size, 15, 15);
          rockyMaterial = new THREE.MeshPhongMaterial({ map: Textures.rockytexture, bumpMap: Textures.rockybump, bumpScale: 1  });
          planet = new THREE.Mesh(geometry, rockyMaterial);
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 100)
        }

        // add habitable planet
        function addHabitable(size, distance, path) {
          geometry = new THREE.SphereGeometry(size, 15, 15);
          habitableMaterial = new THREE.MeshPhongMaterial({ map: Textures.habitabletexture, bumpMap: Textures.habitablebump, bumpScale: 1  });
          planet = new THREE.Mesh(geometry, habitableMaterial);
          scene.add(planet);
          paths[planet.id] = path;
          planets.push(planet);
          planet.position.set(0, distance * 100, 0);
          addCircle(distance * 100)
        }

        // add a orbit circle to the planet
        function addCircle(distance) {
          geometry = new THREE.CircleGeometry( distance, circleSegments );
          geometry.vertices.shift();
          circle = new THREE.Line(geometry,  circleMaterial);
          circles.push(circle);
          scene.add(circle);
        }

        // planets rotation
        function rotatePlanet(planet, index) {
          planet.rotation.z += 0.05;          
          planet.position.y = initialY[index] * 200 * Math.cos(t * speed[index]) + 0 * Math.sin(t * speed[index]);
          planet.position.x = 0 * Math.cos(t * speed[index]) - initialY[index] * 200 * Math.sin(t * speed[index]);
        }

        // Make the planets clickable (for now, it alerts the coordinates)
        document.addEventListener('click', onDocumentMouseClick, false);
        function onDocumentMouseClick() {
          event.preventDefault();
          grabPlanets();
          if (intersects.length > 0) {
            clickedPlanet = intersects[0].object;
            console.log(clickedPlanet.id);
            if (clickedPlanet.id == 6) {
              window.location = "{% url 'star' star.pk %}";
            }
            else if (clickedPlanet.id % 2 == 1)
            {
              window.location = paths[clickedPlanet.id];
            }
          }
        }

        // Deactivate orbit controls when interacting with the panel
        // Show/hide orbit circles
        $('.sidebar').on('mouseenter', function() {
          controls.enabled = false;
          skybox_controls.enabled = false;
          circles.map(function(circle){circle.visible = false});
        });

        $('.sidebar').on('mouseleave', function() {
          controls.enabled = true;
          skybox_controls.enabled = true;
          circles.map(function(circle){circle.visible = true});
        });

        // Register the targeted planet with click events
        function grabPlanets() {
          var offset = {
            x: document.getElementsByTagName("canvas")[0].offsetLeft,
            y: document.getElementsByTagName("canvas")[0].offsetTop,
          }
          mouse.x = ((event.clientX - offset.x) / renderer.domElement.width) * 2 - 1;
          mouse.y = 1 - ((event.clientY - offset.y) / renderer.domElement.height) * 2;
          raycaster.setFromCamera(mouse, camera);
          intersects = raycaster.intersectObjects(scene.children, true);
        };
      });      
    </script>
  {% endblock %}
